name: 'Test action'
on:
  push:
    branches:
      - '*'
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  scan:
    runs-on: ubuntu-latest
    env:
      LETSECRET_SECRETS: ${{ secrets.LETSECRET_SECRETS }}  # 其实是1到9（123...9）
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: run the action
        uses: LetMeFly666/secret-monitor@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
        

# name: 'Let Secret Detector'
# on:
#   push:
#     branches:
#       - '*'
#   pull_request:
#     types: [opened, synchronize, reopened]

# jobs:
#   scan:
#     runs-on: ubuntu-latest
#     env:
#       # LETSECRET_PASSWORD: "password123"
#       LETSECRET_SECRETS: ${{ secrets.LETSECRET_SECRETS }}  # 其实是1到9（123...9）
#     permissions:
#       pull-requests: write
#       contents: read
#     steps:
#       - name: Checkout Codes
#         uses: actions/checkout@v2
#         with:
#           fetch-depth: 0  # 拉取完整的提交历史
#           fetch-all: true  # 拉取所有分支

#       - name: New Commit
#         if: github.event_name == 'push'
#         env: 
#           COMMIT_SHA: ${{ github.sha }}
#         run: |
#           source scripts/scanAllFiles.sh
#           if [[ $(find "/tmp/scan_result/$COMMIT_SHA" -type f) ]]; then
#             echo "::warning file=README.md,line=1::secrets detected"
#             exit 1
#           fi

#       - name: PR - (re)opened
#         if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'reopened')
#         env: 
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#           PR_NUMBER: ${{ github.event.pull_request.number }}
#           REPO_FULL_NAME: ${{ github.repository }}
#         run: |
#           source scripts/getPrCommits_ALL.sh
#           hasLeak=false
#           while IFS= read -r commit_hash; do
#             export COMMIT_SHA="$commit_hash"
#             source scripts/scanAllFiles.sh
#             if [[ $(find "/tmp/scan_result/$COMMIT_SHA" -type f) ]]; then
#               echo "::warning::secrets detected in commit $COMMIT_SHA"
#               hasLeak=true
#             fi
#           done < /tmp/pr_commits_all.txt
#           echo "hasLeak=$hasLeak" >> $GITHUB_ENV
      
#       - name: PR - synchronize
#         if: github.event_name == 'pull_request' && github.event.action == 'synchronize'
#         env: 
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#           PR_NUMBER: ${{ github.event.pull_request.number }}
#           BEFORE_SHA: ${{ github.event.before }}
#           AFTER_SHA: ${{ github.event.after }}
#           REPO_FULL_NAME: ${{ github.repository }}
#         run: |
#           # 获取新commit
#           source scripts/getPrCommits_NEW.sh
#           hasLeak=false
#           while IFS= read -r commit_hash; do
#             export COMMIT_SHA="$commit_hash"
#             source scripts/scanAllFiles.sh
#             if [[ $(find "/tmp/scan_result/$COMMIT_SHA" -type f) ]]; then
#               echo "::warning::secrets detected in commit $COMMIT_SHA"
#               hasLeak=true
#             fi
#           done < /tmp/pr_commits_new.txt
#           echo "hasLeak=$hasLeak" >> $GITHUB_ENV
#           # 备份新commit的scan_result
#           mv /tmp/scan_result /tmp/scan_result.bak
#           # 也读旧commit
#           source scripts/getPrCommits_ALL.sh
#           hasOldLeak=false
#           while IFS= read -r commit_hash; do
#             export COMMIT_SHA="$commit_hash"
#             source scripts/scanAllFiles.sh
#             if [[ $(find "/tmp/scan_result/$COMMIT_SHA" -type f) ]]; then
#               echo "::warning::secrets detected in commit $COMMIT_SHA"
#               hasOldLeak=true
#             fi
#           done < /tmp/pr_commits_all.txt
#           echo "hasOldLeak=$hasOldLeak" >> $GITHUB_ENV
#           # 恢复旧result
#           rm -rf /tmp/scan_result
#           mv /tmp/scan_result.bak /tmp/scan_result
      
#       - name: PR - generate Commit Message
#         if: env.hasLeak == 'true' || env.hasOldLeak == 'true'
#         id: generate-comment
#         env:
#           REPO_FULL_NAME: ${{ github.repository }}
#         run: |
#           if [[ $hasLeak == 'true' ]]; then
#             source scripts/generate1Commit.sh
#           else
#             echo "新commit不包含敏感信息，但历史敏感信息仍未清除" > /tmp/comment_body.txt
#           fi
#           COMMENT_BODY=$(cat /tmp/comment_body.txt)
#           echo "commentBody<<EOF" >> $GITHUB_OUTPUT
#           echo "$COMMENT_BODY" >> $GITHUB_OUTPUT
#           echo "EOF" >> $GITHUB_OUTPUT

#       - name: PR - Commit
#         if: env.hasLeak == 'true'
#         uses: actions/github-script@v6
#         with:
#           script: |
#             const commentBody = `${{ steps.generate-comment.outputs.commentBody }}`;
#             github.rest.issues.createComment({
#               owner: context.repo.owner,
#               repo: context.repo.repo,
#               issue_number: context.payload.pull_request.number,
#               body: commentBody
#             });
      
#       - name: EXIT 1
#         if: env.hasLeak == 'true' || env.hasOldLeak == 'true'
#         run: exit 1

# name: Let Secret Check
# on: [push, pull_request]

# permissions:
#   contents: read
#   issues: write  # 授权Token可写评论

# jobs:
#   scan:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
        
#       - uses: LetMeFly666/secret-monitor@master
#         with:
#           custom_prefix: "MySecret_"  # 可选自定义前缀
#         env:
#           MySecret_DB_PASSWORD: "password123"        # 文本密钥
#           MySecret_IP_REGEX: |
#             /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/ # 正则表达式